## 1. Компиляция в байт-код

java compiler(из JRE) компилирует наши .java файлы в байт-код
и сохраняет в файлы с расширением .class с теми же именами 
(относит.путь \target\classes\{package name}\)

## 2. JVM 
Уже скомпилированные файлы .class JVM интерпретирает в машинный код под конкретную платформу
Во время интерпретации используется JustInTime compiler,
который компилирует частоиспользуемые участки кода в машиный код
и сохраняет их в кеше для быстрого доступа.  

### Class Loading
___JvmComprehension, Object, Integer___
Application ClassLoader сначала ищет у себя в кеше, находит наш JvmComprehension и загружает.
Далее ищет Object, Integer в кеше у родителя - Platform ClassLoader.
Platform ClassLoader не находит и проверяет уже в кеше своего родителя - Bootstrap ClassLoader
Bootstrap ClassLoader находит Object, Integer, загружает их
В обратном порядке доходим до Application ClassLoader, и если какой-то класс не найдет - ClassNotFound Exception

Загрузка классов "ленивая" - происходит по мере появления классов во время интерпретации

### Class Linking
- Verify - проверка на валидность класса, на отсутствие синтаксических ошибок.
- Prepare - выделение памяти под хранение класса, статические объекты/переменные/блоки класса.
- Resolve - не статич./не динамич. поля разрешаются в ссылки на объекты в Heap.

### Class Initializing
Запуск конструктора класса.

После данные о классе(имя,методы, поля и тд) загружаются в Metaspace - это участок памяти в Heap, недоступный для GC,
и там же находится GCRoot.

## 3. 

- `public static void main(String[] args)`:
    В стеке создается фрейм __main()__

  - `int i = 1` (//1):                                        
      Значение примитива хранится в __main()__

  - `Object o = new Object()`  (//2):                                            
       В Куче создается инстанс класса Object,
       Переменной "о" присваивается ссылка на этот инстанс,
       она также хранится во фрейме __main()__

  - `Integer ii = 2` (//3):                                  
    в Куче создается инстанс класса Integer,
    Переменной "ii" присваивается ссылка на этот инстанс
    и она также хранится во фрейме __main()__

    - `printAll(o, i, ii)` (//4):                           
        В стек кладется новый фрейм - __printAll()__
        Параметру метода __printAll()__ "о" присваивается ссылка на ранее созданный инстанс класса Object, 
        она хранится во фрейме __printAll()__
        Параметру "i" присваивается значение переменной i - значение хранится во фрейме __printAll()__
        Параметру "ii" присваивается ссылка на ранее созданный инстанс класса Integer - хранится во фрейме __printAll()__
        
        `Integer uselessVar = 700` (//5):                 
        в Куче создается инстанс класса Integer
        Переменной "uselessVar" присваивается ссылка на этот инстанс - хранится во фрейме __printAll()__
        
      - `System.out.println(o.toString() + i + ii)`(//6):
          "В данном случае произойдет обычная конкатенация, никакого каста - не произойдет. Для значений i и ii - произойдет неявное приведение к типу String.
          Если же будет `System.out.println( i + ii + o.toString());`, то произойдет unboxing переменной ii (неявное приведение к типу int)"

          В стек кладется новый фрейм __println()__
          по ссылке в "о" обращаемся к экземпляру Object
          В стек кладется новый фрейм __.toString()__
          ДАлее фреймы в стек:  __getClass()__; __.getName()__(__initClassName()__);
          __hashCode()__; __toHexString()__ etc.;
          Получение значений, вызовы снимаются со стека до __println()__
          Конкатенация строки
          создание экземпляра String в Heap??
          Проваливаемся в __println()__ 
              + еще фреймы в стек
          Печать
    
      - фрейм __println()__ снимается со стека
       
   
  - фрейм __printAll()__ снимается со стека:
        ссылки на "uselessVar", параметров "о" и "ii", String теряют связь с GCRoot,
        значение"i" стирается вместе с фреймом

  - `System.out.println("finished")`(//7):
      В стек кладется ещё фрейм __println()__
      создание экземпляра String в Heap??
      Проваливаемся в __println()__ - еще фреймы в стек
      Печать finished
     
      - __println()__ снимается со стека,напечатанная String теряет связь с GCRoot
    
- __main()__ снимается со стека
      